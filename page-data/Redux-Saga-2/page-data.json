{"componentChunkName":"component---src-templates-blog-post-js","path":"/Redux-Saga-2/","result":{"data":{"markdownRemark":{"html":"<h3 id=\"redux-saga-effects\">Redux-Saga Effects</h3>\n<p>Some unmentioned Redux-Saga operations, such as <strong><code>takeEvery</code></strong>, <strong><code>take</code></strong>, <strong><code>fork</code></strong> etc., are also essentially Effect creating functions. They don't directly execute function calls or dispatch actions, but return an Effect description object instead. This object contains instructions on what operation to execute, such as which function to call, what are the parameters (for <strong><code>call</code></strong>), or which action to dispatch (for <strong><code>put</code></strong>).</p>\n<p>The benefit of this design is that the Saga function itself remains pure; it only returns a series of Effect description objects, rather than directly executing side-effect operations. This makes Saga functions easier to test, as you can directly check the Effect description objects returned by the Saga function, without needing to mock function calls or action dispatches.</p>\n<p>Actual function calls or action dispatches are performed by Redux-Saga middleware. When a Saga function returns an Effect description object through a <strong><code>yield</code></strong> statement, Redux-Saga middleware takes over the Effect and performs operations based on the information in the Effect description. For example, for the <strong><code>call</code></strong> Effect, the middleware calls the specified function with the specified parameters; for the <strong><code>put</code></strong> Effect, the middleware dispatches the specified action.</p>\n<p>So, you can understand that <strong><code>call</code></strong> and <strong><code>put</code></strong> are telling Redux-Saga middleware: \"I want to do this operation, you help me do it\". Instead of directly executing the operation. This is why we say they return an Effect that describes an operation, rather than immediately executing an operation.</p>\n<h3 id=\"moving-checkusersession-to-redux-saga\">Moving checkUserSession to Redux-Saga</h3>\n<p>In our application, we need to get the user's status when they log in. In the previous implementation, we used the Firebase API's <strong><code>onAuthStateChangedListener</code></strong> to listen for changes in the user's authentication status. However, while this Listener method can work, it is not convenient for us to manage and monitor state. To solve this problem, we decided to move this asynchronous operation into Redux-Saga.</p>\n<p>First, we create a function named <strong><code>getCurrentUser</code></strong>, which returns a new Promise:</p>\n<pre><code class=\"language-jsx\">export const getCurrentUser = () => {\n  return new Promise((resolve, reject) => {\n    const unsubscribe = onAuthStateChanged(\n      auth,\n      userAuth => {\n        unsubscribe()\n        resolve(userAuth)\n      },\n      reject\n    )\n  })\n}\n</code></pre>\n<p>Here, the first argument of <strong><code>onAuthStateChanged</code></strong> is <strong><code>auth</code></strong>, which we previously returned with <strong><code>getAuth</code></strong>, representing the current authentication information. The second function will be executed when the Promise is successfully returned. When the authentication status changes, we immediately execute unsubscribe to cancel listening (to avoid memory leaks) and use the <strong><code>resolve</code></strong> method to return the user's authentication information. The third argument is executed when rejected, if an error occurs, we use the <strong><code>reject</code></strong> method to return the error.</p>\n<p>Next, we add a few new action types to <strong><code>USER_ACTION_TYPES</code></strong> to meet our needs:</p>\n<pre><code class=\"language-jsx\">export const USER_ACTION_TYPES = {\n  SET_CURRENT_USER: \"user/SET_CURRENT_USER\",\n  GOOGLE_SIGN_IN_START: \"user/GOOGLE_SIGN_IN_START\",\n  CHECK_USER_SESSION: \"user/CHECK_USER_SESSION\",\n  EMAIL_SIGN_IN_START: \"user/EMAIL_SIGN_IN_START\",\n  SIGN_IN_SUCCESS: \"user/SIGN_IN_SUCCESS\",\n  SIGN_IN_FAILED: \"user/SIGN_IN_FAILED\",\n}\n</code></pre>\n<p>Then we create the Saga. Our requirement here is to check the current user status, so we first create an <strong><code>onCheckUserSession</code></strong> saga to bind <strong><code>CHECK_USER_SESSION</code></strong>. As soon as a CHECK_USER_SESSION action is heard from the user, the <strong><code>isUserAuthenticated</code></strong> saga is automatically executed.</p>\n<p>What <strong><code>isUserAuthenticated</code></strong> does is to call the <strong><code>getCurrentUser</code></strong> function to get the user's authentication information, and then update our status based on this information. Here <strong><code>call(getCurrentUser)</code></strong>, and the returned promise result is put into userAuth. (Of course, if no promise result is returned, it means that the current user is not logged in, then just return directly, so the value of currentUser is still null).</p>\n<p>Then, call <strong><code>getSnapshotFromUserAuth</code></strong> again and pass in <strong><code>userAuth</code></strong> to get <strong><code>userSnapshot</code></strong>. This snapshot contains the user information we need. What <strong><code>put(signInSuccess)</code></strong> does is to send the action to the user reducer again, and update the user data in the snapshot into the store through the reducer. In this way, our store contains our user information.</p>\n<pre><code class=\"language-jsx\">import { takeLatest, put, all, call } from \"redux-saga/effects\"\nimport { USER_ACTION_TYPES } from \"./user.types\"\nimport { signInSuccess, signInFailed } from \"./user.action\"\nimport {\n  getCurrentUser,\n  createUserDocumentFromAuth,\n} from \"../../utils/firebase/firebase.utils\"\n\nexport function* getSnapshotFromUserAuth(userAuth, additionalDetails) {\n  try {\n    const userSnapshot = yield call(\n      createUserDocumentFromAuth,\n      userAuth,\n      additionalDetails\n    )\n    yield put(signInSuccess({ id: userSnapshot.id, ...userSnapshot.data() }))\n    //Here, due to firebase, id will not exist in snapshot.data(), so we need to extract id separately\n  } catch (error) {\n    yield put(signInFailed(error))\n  }\n}\n\nexport function* isUserAuthenticated() {\n  try {\n    const userAuth = yield call(getCurrentUser)\n    if (!userAuth) return\n    yield call(getSnapshotFromUserAuth, userAuth)\n    // yield put(signInSuccess(userAuth));\n  } catch (error) {\n    yield put(signInFailed(error))\n  }\n}\n\nexport function* onCheckUserSession() {\n  yield takeLatest(USER_ACTION_TYPES.CHECK_USER_SESSION, isUserAuthenticated)\n}\n\nexport function* userSagas() {\n  yield all([call(onCheckUserSession)])\n}\n</code></pre>\n<pre><code class=\"language-jsx\">export const userReducer = (state = INITIAL_STATE, action) => {\n  // console.log(state, action);\n  const { type, payload } = action\n\n  switch (type) {\n    case USER_ACTION_TYPES.SIGN_IN_SUCCESS:\n      return { ...state, currentUser: payload }\n    //...\n\n    default:\n      return state\n  }\n}\n</code></pre>\n<p>Finally, all we need to do is dispatch the <strong><code>checkUserSession</code></strong> action in <strong><code>app.js</code></strong>. In this way, when the component is mounted, <strong><code>checkUserSession</code></strong> will send a <strong><code>USER_ACTION_TYPES.CHECK_USER_SESSION</code></strong> action, and it will be received by <strong><code>onCheckUserSession</code></strong> in user saga through <strong><code>takeLatest</code></strong>. After that, the process is the same as mentioned above.</p>\n<pre><code class=\"language-jsx\">useEffect(() => {\n  dispatch(checkUserSession())\n}, [])\n</code></pre>\n<p>Of course, let's not forget to add <code>userSagas</code> in the root saga for implementation and monitoring:</p>\n<pre><code class=\"language-jsx\">import { all, call } from \"redux-saga/effects\"\n\nimport { categoriesSaga } from \"./categories/category.saga\"\nimport { userSagas } from \"./user/user.saga\"\n\nexport function* rootSaga() {\n  yield all([call(categoriesSaga), call(userSagas)])\n}\n</code></pre>\n<p>Let's retrace the entire process once more: <code>rootSaga</code> adds <code>call(userSagas)</code>, <code>useEffect</code> in <code>app.js</code> dispatches to <code>checkUserSession</code> during mount, which is picked up by <code>onCheckUserSession</code>'s <code>takeLatest</code>, executing <code>isUserAuthenticated</code>; <code>isUserAuthenticated</code> calls <code>getCurrentUser</code> and receives the returned promise. If the promise exists, it continues to call <code>getSnapshotFromUserAuth</code>, passing in <code>userAuth</code> as an argument. If successful, it emits a <code>signInSuccess</code> action, storing the data that includes an ID as payload into <code>currentUser</code>.</p>","tableOfContents":"<ul>\n<li><a href=\"#redux-saga-effects\">Redux-Saga Effects</a></li>\n<li><a href=\"#moving-checkusersession-to-redux-saga\">Moving checkUserSession to Redux-Saga</a></li>\n</ul>","frontmatter":{"title":"Redux-Saga-2","date":"2022-12-22"}}},"pageContext":{"slug":"/Redux-Saga-2/"}},"staticQueryHashes":["3649515864"],"slicesMap":{}}