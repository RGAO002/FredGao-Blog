{"componentChunkName":"component---src-templates-blog-post-js","path":"/Typing-Saga/","result":{"data":{"markdownRemark":{"html":"<h3 id=\"installing-libraries-and-modifying-tsconfig\">Installing Libraries and Modifying tsconfig</h3>\n<p>For TypeScript in Saga, we first need to do some preparations by installing two libraries:</p>\n<pre><code class=\"language-markdown\">npm install typed-redux-saga\nnpm install --also=dev babel-plugin-macros\n</code></pre>\n<p>The <strong><code>typed-redux-saga</code></strong> needs no introduction, as it's the TypeScript library for Redux-Saga. Let's briefly explain the role of the <strong><code>babel-plugin-macros</code></strong> library, starting with <strong><code>typed-redux-saga</code></strong> and <strong><code>typed-redux-saga/macro</code></strong>.</p>\n<p>When you install the <strong><code>typed-redux-saga</code></strong> package via npm (or yarn), <strong><code>typed-redux-saga/macro</code></strong> is also installed. They are both part of the same npm package, just imported differently.</p>\n<p><strong><code>typed-redux-saga</code></strong> and <strong><code>typed-redux-saga/macro</code></strong> essentially offer the same functionality. They both allow you to use Redux-Saga in a TypeScript environment with excellent type hints and type checking. Their difference lies in that <strong><code>typed-redux-saga/macro</code></strong> leverages the capabilities of the <strong><code>babel-plugin-macros</code></strong> library.</p>\n<p><strong><code>babel-plugin-macros</code></strong> provides a way to use Babel plugins in your project without modifying Babel configurations. These \"macros\" are special Babel plugins that execute at compile time and change your source code.</p>\n<p><strong><code>typed-redux-saga/macro</code></strong> is such a macro. It replaces the <strong><code>yield*</code></strong> expressions in your source code with <strong><code>yield</code></strong> expressions during compile time, as the latter have better compatibility in the JavaScript runtime environment.</p>\n<p>Therefore, if your project already uses Babel and you want type safety without changing runtime behavior, you can choose to use <strong><code>typed-redux-saga/macro</code></strong>. If your project does not use Babel or if you don't mind using <strong><code>yield*</code></strong> directly in the source code, you can choose to use <strong><code>typed-redux-saga</code></strong>.</p>\n<p>Next, we need to add a setting in tsconfig:</p>\n<pre><code class=\"language-json\">{\n  \"compilerOptions\": {\n    //...\n    \"downlevelIteration\": true\n  }\n}\n</code></pre>\n<p>Why do we need to add this setting?</p>\n<p>In TypeScript, when you iterate (for example, using a for-of loop) over certain types of objects (like Set, Map, or generator, etc.), you may encounter issues. This is because TypeScript compiles ES6+ syntax to ES5 or earlier versions by default. However, these earlier versions of JavaScript do not support iterating over newer data structure types (like Set or Map) or generators.</p>\n<p><strong><code>downlevelIteration</code></strong> is a TypeScript compilation option. When you set <strong><code>\"downlevelIteration\": true</code></strong>, the TypeScript compiler generates code that can correctly iterate over these new data structure types and generators in an ES5 or earlier JavaScript environment. This handling might result in larger compiled code, but it ensures that your code runs correctly in older JavaScript environments.</p>\n<p>Redux-Saga uses generator and iterator. That's why when using the TypeScript version of Redux-Saga, you need to set <strong><code>\"downlevelIteration\": true</code></strong> in the <strong><code>tsconfig.json</code></strong> file. Without this, your saga might not work correctly, especially in some older JavaScript environments.</p>\n<h3 id=\"major-migration-changes\">Major Migration Changes</h3>\n<p>When migrating Redux-Saga from JavaScript to TypeScript, we need to make some modifications that involve not only changes in syntax but also code organization and type definitions. Here are some changes you'll make during the migration process from JavaScript to TypeScript in Redux Saga:</p>\n<ol>\n<li>In the JavaScript version, we use functions from the <strong><code>redux-saga/effects</code></strong> library. In the TypeScript version, we need to use the <strong><code>typed-redux-saga</code></strong> library, which provides the same functions as <strong><code>redux-saga/effects</code></strong>, but with added type checking.</li>\n</ol>\n<pre><code class=\"language-tsx\">import { takeLatest, put, all, call } from \"typed-redux-saga/macro\"\n</code></pre>\n<ol start=\"2\">\n<li>All Saga functions in JavaScript do not have parameter type annotations. In TypeScript, we need to add type annotations for each Saga function's parameters. This can help us discover type errors and make our code more readable and maintainable.</li>\n</ol>\n<pre><code class=\"language-tsx\">export function* signInWithEmail({\n  payload: { email, password },\n}: EmailSignInStart) {...}\n</code></pre>\n<ol start=\"3\">\n<li>In TypeScript, we need to use <strong><code>yield*</code></strong> instead of <strong><code>yield</code></strong>. [This is because the <strong><code>typed-redux-saga</code></strong> library uses <strong><code>yield*</code></strong> to achieve a type-safe effect.]</li>\n</ol>\n<pre><code class=\"language-tsx\">const { user } = yield * call(signInWithGooglePopup)\n</code></pre>\n<ol start=\"4\">\n<li>In TypeScript, <a href=\"https://www.notion.so/React-Web-Application-0b0defe753f1458a999195e2080bdbe9?pvs=21\">we need to explicitly annotate error types as <strong><code>Error</code></strong></a>. This way, we can ensure that the error object in the catch block is always an instance of Error.</li>\n</ol>\n<pre><code class=\"language-tsx\">catch (error) {\n  yield* put(signInFailed(error as Error));\n}\n</code></pre>\n<ol start=\"5\">\n<li>In JavaScript, we do not need to define the types of actions. But in TypeScript, we need to define a type for each action. This way, we can use these types in reducers and sagas to ensure that our code is type-safe.</li>\n</ol>\n<pre><code class=\"language-tsx\">export type SignInSuccess = ActionWithPayload&#x3C;\n  USER_ACTION_TYPES.SIGN_IN_SUCCESS,\n  UserData\n>\n</code></pre>\n<ol start=\"6\">\n<li>In JavaScript, we use a regular function to create an action. In TypeScript, we need to use a function with type annotations to create an action.</li>\n</ol>\n<pre><code class=\"language-tsx\">export const signInSuccess = withMatcher(\n  (user: UserData &#x26; { id: string }): SignInSuccess =>\n    createAction(USER_ACTION_TYPES.SIGN_IN_SUCCESS, user)\n)\n</code></pre>","tableOfContents":"<ul>\n<li><a href=\"#installing-libraries-and-modifying-tsconfig\">Installing Libraries and Modifying tsconfig</a></li>\n<li><a href=\"#major-migration-changes\">Major Migration Changes</a></li>\n</ul>","frontmatter":{"title":"Typing Sagas","date":"2023-03-16"}}},"pageContext":{"slug":"/Typing-Saga/"}},"staticQueryHashes":["3649515864"],"slicesMap":{}}