{"componentChunkName":"component---src-templates-blog-post-js","path":"/Redux-Saga-1/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"using-redux-saga-middleware\">Using Redux-Saga Middleware</h2>\n<p>Similar to Redux-Thunk, Redux-Saga is a middleware for managing asynchronous operations (Side Effect) of Redux applications, created by Yassine Elouafi, a developer from Canada. Redux-Saga uses the Generator feature of ES6, making asynchronous processes easier to read, write, and test. In this way, developers can clearly describe the asynchronous process in the application.</p>\n<h3 id=\"generator-function\">Generator Function</h3>\n<p>Before delving into Redux-Saga, we need to first understand the Generator function in JavaScript. The Generator function is an asynchronous programming solution provided by ES6, with syntax behavior completely different from traditional functions, defined as <strong><code>function*</code></strong>, and it can use the <strong><code>yield</code></strong> keyword to pause the execution of the function. It can be paused and resumed. Generator functions have multiple states, which can switch back and forth, which is why they can handle asynchronous operations.</p>\n<p>The Generator function is a state machine that encapsulates multiple internal states. When you call a Generator function, it does not immediately execute the code in the function body, but instead returns a special iterator, called a Generator object. This Generator object has a <strong><code>next</code></strong> method. You can control the execution of the Generator function by calling this <strong><code>next</code></strong> method. In other words, the Generator function is not only a state machine but also a function to generate iterator objects. The returned iterator object can traverse each state in the Generator function one by one.</p>\n<p>Each time the <strong><code>next</code></strong> method is called, the Generator function will start executing from where it was last paused until it encounters the next <strong><code>yield</code></strong> expression or the function ends. The <strong><code>next</code></strong> method returns an object, the <strong><code>value</code></strong> attribute of this object is the value of the <strong><code>yield</code></strong> expression, and the <strong><code>done</code></strong> attribute is a Boolean value indicating whether the Generator function has finished executing.</p>\n<p>A simple Generator function can be written like this:</p>\n<pre><code class=\"language-jsx\">function* gen() {\n\tconsole.log('a');\n\tyield;\n\tconsole.log('b');\n}\n\nconst g = gen()\ng //gen {&#x3C;suspended>}\n\ng.next() //a b {value: undefined, done: true}\n\nfunction* gen2(i)\n{\n\tyield i;\n\tyield i + 10;\n}\nconst g2 = gen2(5)\n\nconst gObj = g2.next()\nconsole.log(gObj) //{value: 5, done: false}\n\nconst jObj = g2.next()\nconsole.log(jObj) //{value: 15, done: false}\n\nconsole.log(g2.next()) {value: undefined, done: true}\n</code></pre>\n<p>In this example, <strong><code>gen2</code></strong> is a Generator function, which defines two states (through the <strong><code>yield</code></strong> keyword). We can traverse these states using the <strong><code>next</code></strong> method.</p>\n<p>In addition to <strong><code>yield</code></strong> and <strong><code>next</code></strong>, the Generator function has two important methods: <strong><code>throw</code></strong> and <strong><code>return</code></strong></p>\n<p>The <strong><code>throw</code></strong> method: can throw an error outside the Generator function, and then catch it inside the Generator function. If the error is not caught by the <strong><code>try...catch</code></strong> statement inside the Generator function, then the error will be received by the object returned by the <strong><code>throw</code></strong> method.</p>\n<p>The <strong><code>return</code></strong> method: can end the execution of the Generator function in advance, and set the <strong><code>done</code></strong> attribute to <strong><code>true</code></strong>. The <strong><code>return</code></strong> method accepts a parameter, which will become the <strong><code>value</code></strong> attribute of the object returned by the <strong><code>next</code></strong> method.</p>\n<h3 id=\"redux-saga-workflow\">Redux-Saga Workflow</h3>\n<p>First, we need to install Redux-Saga in the project:</p>\n<pre><code>npm install redux-saga\n</code></pre>\n<p>Create a <code>**root-saga.js</code>**:</p>\n<pre><code class=\"language-jsx\">import { all, call } from \"redux-saga/effects\"\n\nimport { categoriesSaga } from \"./categories/category.saga\"\n\nexport function* rootSaga() {\n  yield all([call(categoriesSaga)])\n}\n</code></pre>\n<p><strong><code>rootSaga</code></strong> is a core concept in Redux-Saga, it is the entry point of all sagas (or all asynchronous operations). In a large application, you may have many different sagas, each saga is responsible for handling a specific asynchronous operation. <strong><code>rootSaga</code></strong> is where all these sagas are organized and started.</p>\n<p><strong><code>rootSaga</code></strong> is a Generator function, it uses the <strong><code>yield all([call(categoriesSaga)]);</code></strong> line of code to start all sagas. The <strong><code>all</code></strong> and <strong><code>call</code></strong> here are the effect creation functions of Redux-Saga.</p>\n<ul>\n<li>\n<p>The <strong><code>all</code></strong> function is used to start multiple sagas at the same time. It receives an array of sagas and starts all of them in parallel.</p>\n</li>\n<li>\n<p>The <strong><code>call</code></strong> function is used to call a function (which should be a Generator function). It can also pass parameters to this function. This is similar to calling a function directly, but in Redux-Saga, if you want to call a function, you need to use the <strong><code>call</code></strong> function to do it.</p>\n</li>\n</ul>\n<p>So, the line of code <strong><code>yield all([call(categoriesSaga)]);</code></strong> means to execute the <strong><code>categoriesSaga</code></strong> saga in parallel. If there are more sagas, they can all be put into this array, for example: <strong><code>yield all([call(categoriesSaga), call(userSaga), call(orderSaga)]);</code></strong>.</p>\n<p>Next, in <strong><code>store.js</code></strong>, import, add and run Redux-Saga middleware:</p>\n<pre><code class=\"language-jsx\">//Other imports and configs omitted\nimport createSagaMiddleware from \"redux-saga\"\nimport { rootSaga } from \"./root-saga\"\n\nconst sagaMiddleware = createSagaMiddleware()\n\nconst middleWares = [\n  process.env.NODE_ENV === \"development\" &#x26;&#x26; logger,\n  sagaMiddleware,\n].filter(Boolean)\n\nsagaMiddleware.run(rootSaga)\n</code></pre>\n<p>Then, taking category reducer as an example, we will modify the <code>**fetchCategoriesAsync**</code> action that previously called Redux-Thunk to use Redux-Saga. <strong>Both are middlewares for handling asynchronous operations in Redux, and are generally not used at the same time.</strong></p>\n<pre><code class=\"language-jsx\">import { takeLatest, all, call, put } from \"redux-saga/effects\"\n\nimport { getCategoriesAndDocuments } from \"../../utils/firebase/firebase.utils\"\n\nimport {\n  fetchCategoriesSuccess,\n  fetchCategoriesFailed,\n} from \"./category.action\"\n\nimport { CATEGORIES_ACTION_TYPES } from \"./category.types\"\n\nexport function* fetchCategoriesAsync() {\n  try {\n    const categoriesArray = yield call(getCategoriesAndDocuments, \"categories\")\n    yield put(fetchCategoriesSuccess(categoriesArray))\n  } catch (err) {\n    yield put(fetchCategoriesFailed(err))\n  }\n}\n\nexport function* onFetchCategories() {\n  yield takeLatest(\n    CATEGORIES_ACTION_TYPES.FETCH_CATEGORIES_START,\n    fetchCategoriesAsync\n  )\n}\n\nexport function* categoriesSaga() {\n  yield all([call(onFetchCategories)])\n}\n</code></pre>\n<p>In Redux-Saga, a Saga is a Generator function, any function that contains <code>**yield**</code> and other <code>**Generator**</code> function keywords can be called a Saga. We can use the <strong><code>yield</code></strong> keyword in this function to describe our asynchronous operation. In this example, <strong><code>fetchCategoriesAsync</code></strong> is a Saga that describes an asynchronous operation: first, we use <strong><code>yield call</code></strong> to call the <strong><code>getCategoriesAndDocuments</code></strong> function to get category information; then, we use <strong><code>yield put</code></strong> to dispatch an action to update the state of the Redux store.</p>\n<p><strong><code>yield call</code></strong> is an effect creator, it is used to create effects that describe \"call function\". In our example, <strong><code>yield call(getCategoriesAndDocuments, \"categories\")</code></strong> creates an effect that describes the operation of calling the <strong><code>getCategoriesAndDocuments</code></strong> function. The Redux-Saga middleware will handle these effects when executing the Generator function. For <strong><code>call</code></strong> effect, the middleware will call the given function and suspend the Generator function until the function returns. That is to say, any call to a function in a Saga must use <code>**call**</code>.</p>\n<p><strong><code>yield put</code></strong> is also an effect creator, it is used to create effects that describe \"dispatch action\". In our example, <strong><code>yield put(fetchCategoriesSuccess(categoriesArray))</code></strong> creates an effect that describes the operation of dispatching <strong><code>fetchCategoriesSuccess</code></strong> action. The Redux-Saga middleware will handle these effects when executing the Generator function. For the <strong><code>put</code></strong> effect, the middleware will dispatch the given action. This effect describes a dispatch action operation, not an immediate dispatch action. When we dispatch an action in a Saga, we use the <code>**put**</code> keyword.</p>\n<p><strong><code>yield takeLatest</code></strong> is a helper function, it creates a Saga that forks a new task to execute the given Saga each time it receives the specified action. If this Saga has already forked a task when it received the action last time and this task has not yet ended, then <strong><code>takeLatest</code></strong> will cancel this task. This means that if multiple identical actions are dispatched, <strong><code>takeLatest</code></strong> will only execute the Saga corresponding to the last action. Therefore, <code>**takeLatest**</code> is essentially a binding to an action, similar to watching an action and responding in a Saga, just like a reducer. However, it usually does not return a new state object like a reducer, it usually executes another Saga.</p>\n<p><code>**yield all**</code> is an effect creator, it is used to handle multiple effects in parallel. In our example, <strong><code>yield all([call(onFetchCategories)])</code></strong> creates an effect that describes the operation of calling <strong><code>onFetchCategories</code></strong> in parallel. The Redux-Saga middleware will handle these effects when executing the Generator function. For the <strong><code>all</code></strong> effect, the middleware will handle all effects in parallel and suspend the Generator function until all effects are handled. Any action that needs to be monitored must be registered in <code>**yield all**</code>. This allows us to manage all Sagas centrally in one place, rather than manage them separately in multiple places.</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#using-redux-saga-middleware\">Using Redux-Saga Middleware</a></p>\n<ul>\n<li><a href=\"#generator-function\">Generator Function</a></li>\n<li><a href=\"#redux-saga-workflow\">Redux-Saga Workflow</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Redux-Saga-1","date":"2022-11-23"}}},"pageContext":{"slug":"/Redux-Saga-1/"}},"staticQueryHashes":["3649515864"],"slicesMap":{}}